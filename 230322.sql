CREATE TABLE DEPT_TEMP 
AS SELECT *FROM DEPT;

SELECT *FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO,DNAME,LOC)
VALUES(50,'DATABASE','SEOUL');
INSERT INTO DEPT_TEMP (DEPTNO,DNAME,LOC)
VALUES(70,'WEB',NULL);
INSERT INTO DEPT_TEMP (DEPTNO,DNAME,LOC)
VALUES(80,'MOBILE','');
INSERT INTO DEPT_TEMP (DEPTNO,LOC)
VALUES(90,'INCHEON');


SELECT *FROM DEPT_TEMP;


-- 컬럼값만 복사해서 새로운 테이블 생성, WHERE 조건걸에 1<>1
CREATE TABLE EMP_TEMP
AS SELECT *
FROM EMP
WHERE 1<>1;

SELECT *FROM EMP_TEMP;

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999,'홍길동','PRESIDENT',NULL,'2001/01/01',5000,1000,10);

--여기서 DATE로 오류나면 이렇게 바꾸자
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999,'홍길동','PRESIDENT',NULL,TO_DATE('2001/01/01', 'YYYY/MM/DD'),5000,1000,10);


--근데 모든  VALUES 를 다 넣을 거면, 이렇게 길게 쓸 필요없다
 INSERT INTO EMP_TEMP
 VALUES(9999,'김진희','PRESIDENT',NULL,'2001/01/01',10000,1000,10);

--이렇게 일부만 입력할 수도 있다!
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO)
VALUES(9999,'홍길동','PRESIDENT',NULL,'2001/01/01',10);


SELECT *FROM EMP_TEMP;

--SUB쿼리 사용하여 데이터 입력
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
 SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
 FROM EMP E, SALGRADE S
 WHERE e.SAL BETWEEN s.LOSAL 
 				AND s.HISAL 
 				AND s.GRADE = 1;
 			
SELECT *FROM EMP_TEMP;


--자 이거 하기전에 수동  COMMIT으로 전환하고!
CREATE TABLE DEPT_TEMP2
AS SELECT *FROM DEPT;

SELECT *FROM DEPT_TEMP2

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL';

SELECT *FROM DEPT_TEMP2;

ROLLBACK; --------------------- ROLLBACK 하면, SEOUL로 바꿨던게 다시 원상복귀 된다!
 		
SELECT *FROM DEPT_TEMP2;	


UPDATE DEPT_TEMP2
 SET DNAME = 'DATABASE',
 		LOC = 'SEOUL'
 WHERE DEPTNO = 40;

SELECT *FROM DEPT_TEMP2;	--- 서울로 변경됨


UPDATE DEPT_TEMP2
 SET(DNAME, LOC) = (SELECT DNAME, LOC
 					FROM DEPT
 					WHERE DEPTNO = 40)
 WHERE DEPTNO =40;


SELECT *FROM DEPT_TEMP2; ---다시 BOSTON 으로 변경됨(DEPT 테이블에서 가져온 값으로 변경)


-- 서브 쿼리 사용
UPDATE DEPT_TEMP2
SET DNAME = (SELECT DNAME 
				FROM DEPT
				WHERE DEPTNO = 40),
	LOC = (SELECT LOC
				FROM DEPT
				WHERE DEPTNO = 40)
WHERE DEPTNO = 40
;

SELECT *FROM DEPT_TEMP2
;

COMMIT;



CREATE TABLE EMP_NEW(
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB   VARCHAR2(9),
	MGR   NUMBER(4),
	HIREDATE DATE,
	SAL   NUMBER(7,2),  --------------------7,2 (소수점 2)
	COMM  NUMBER(7,2),
	DEPTNO NUMBER(2)
	)
;

ALTER TABLE EMP_NEW
 ADD HP VARCHAR2(20)
;

SELECT * FROM EMP_NEW;

ALTER TABLE EMP_NEW
 RENAME COLUMN HP TO TEL_NO
;


ALTER TABLE EMP_NEW
 MODIFY EMPNO NUMBER(5)
;


TRUNCATE TABLE EMP_NEW; ------데이터 전부 삭제

DROP TABLE EMP_TEMP; ------테이블 자체 삭제(실행 주의!!!!!!!!)
ROLLBACK; --원상태로 회복하려면.... AUTO COMMIT 인데도 작동이 되네??


 --P229----------------------SEQUENCE!!!!!!!

CREATE SEQUENCE SEQ_DEPTSEQ
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 999
	MINVALUE 1
	NOCYCLE --	NOCYCLE : 최대값에서 중단
	NOCACHE; -- NOCACHE : 값 미리 생성 (기본 20)
	
CREATE TABLE DEPTSEQ AS SELECT *FROM DEPT;

INSERT INTO DEPTSEQ(DEPTNO,DNAME,LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL,'DATABASE','SEOUL');

INSERT INTO DEPTSEQ(DEPTNO,DNAME,LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL,'WEB','BUSAN');

INSERT INTO DEPTSEQ(DEPTNO,DNAME,LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL,'MOBILE','ILSAN');

SELECT *FROM DEPTSEQ;


--제약 조건
--테이블을 생성할 때, 테이블 컬럼별 제약 조건을 설정
--NOT NULL
--UNIQUE
--PK
 CREATE TABLE LOGIN(
 			LOGIN_ID   VARCHAR2(20) NOT NULL
 			,LOGIN_PWD VARCHAR2(20) NOT NULL
 			,TEL       VARCHAR2(20)
 );

INSERT INTO LOGIN(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID',NULL,'010-1234-5678'); ----PWD 없어서 오류남

INSERT INTO LOGIN(LOGIN_ID, LOGIN_PWD)
VALUES('TEST_ID2','1234');
 

SELECT *FROM LOGIN;

ALTER TABLE LOGIN 
MODIFY(TEL NOT NULL); ---TEL에 NULL 값 발견되서 변경안된다고 뜸(null values found). 여기선 제약조건 이름 설정안함! 자동생성!


UPDATE LOGIN
SET TEL = '010-0000-0000'
WHERE LOGIN_ID = 'TEST_ID'; 


UPDATE LOGIN
SET TEL = '010-0000-0000'
WHERE TEL IS NULL;  -----------이렇게는 안되네... 왜 안되지????


SELECT *FROM LOGIN;
 
SELECT OWNER
		,CONSTRAINT_NAME
		,CONSTRAINT_TYPE
		,TABLE_NAME
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'LOGIN'


ALTER TABLE LOGIN 
 DROP CONSTRAINT SYS_C007115;   ---------TEL 제약조건 날리고,,SYS_C007115 이거 자동생성된거..!

ALTER TABLE LOGIN 
 MODIFY (TEL CONSTRAINT TELNOTNULL NOT NULL); ------TEL 제약조건 이름바꿔서 다시 주자!
 
 	
SELECT OWNER
		,CONSTRAINT_NAME
		,CONSTRAINT_TYPE
		,TABLE_NAME
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'LOGIN'   -----------바뀐 제약조건 재확인!!!


--P234  UNIQUE-----------------------------------다 못함.... 
CREATE TABLE LOGIN_UNIQUE(
	LOGIN_ID VARCHAR(20) UNIQUE,
	LOGIN_PW VARCHAR(20) NOT NULL,
	TEL VARCHAR2(20)
);

SELECT OWNER
		,CONSTRAINT_NAME
		,CONSTRAINT_TYPE
		,TABLE_NAME
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'LOGIN_UNIQUE'



--P236 PRIMARY KEY 
CREATE TABLE TABLE_PK(
		LOGIN_ID VARCHAR2(20) PRIMARY KEY
		,LOGIN_PWD VARCHAR2(20) NOT NULL
		,TEL VARCHAR2(20)
	
);

SELECT OWNER
		,CONSTRAINT_NAME
		,CONSTRAINT_TYPE
		,TABLE_NAME
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'TABLE_PK'

INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('PK01', '1234','010-1235-5678');
INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('PK02', '1234','010-1235-5678');
INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('PK02', '1234','010-1235-5678'); --------- 이미 PK01 있어서 생성   X


-- 인덱스
--장점 : 순식간에 원하는 답을 찾아 준다.
--단점 : 입력과 출력이 잦은 경우, 인덱스가 설정된 테이블의 속도가 저하된다.

 CREATE INDEX IDX_EMP_JOB
 ON EMP(JOB)
 ;

SELECT *
FROM USER_INDEXES
WHERE TABLE_NAME IN('EMP','DEPT')

;



-- VIEW

CREATE VIEW VW_EMP
 AS (SELECT EMPNO,ENAME,JOB,DEPTNO
 		FROM EMP WHERE DEPTNO = 10);
 	
 	

-------ROWNUM-----------------------------------------
SELECT ROWNUM
		,E.*
FROM EMP E
ORDER BY SAL DESC

SELECT ROWNUM, E.*
		FROM (SELECT *
			FROM EMP E
			ORDER BY SAL DESC)E -------- E 별칭으로 인라인-뷰 사용;
WHERE ROWNUM <=5;


SELECT *
 FROM DICT
 WHERE TABLE_NAME LIKE 'USER_%';

SELECT *
 FROM DBA_TABLES
 WHERE TABLE_NAME LIKE 'EMP%'
;

		


